<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shooting Game</title>
    <style>
        :root {
            --white: #FFFFFF;
            --red: #FF0000;
            --green: #0d8c0d;
            --yellow: #ffcc00;
            --bg-dark: #020205;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background: var(--bg-dark); overflow: hidden;
            font-family: 'Segoe UI', 'Courier New', monospace;
            color: white; user-select: none;
        }

        canvas { display: block; filter: contrast(1.1) brightness(1.1); }

        #crt-layer {
            position: fixed; inset: 0; pointer-events: none; z-index: 100;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%),
                        linear-gradient(90deg, rgba(255, 0, 0, 0.02), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.02));
            background-size: 100% 3px, 3px 100%; 
            opacity: 0.5;
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 50;
            backdrop-filter: blur(10px);
            transition: 0.5s;
        }

        .hidden {
            display: none !important;
            opacity: 0; 
        }

        .menu-card {
            background: rgba(10, 10, 25, 0.8);
            border: 1px solid var(--white);
            padding: 50px; 
            border-radius: 4px; 
            text-align: center;
            box-shadow: 0 0 60px rgba(0, 242, 255, 0.15); 
            max-width: 700px;
        }

        h1 {
            font-size: 4.5rem;
            margin: 0;
            letter-spacing: 12px;
            color: var(--white);
            text-shadow: 0 0 20px var(--white);
            font-weight: 900; 
        }
        h2 {
            color: var(--green);
            text-transform: uppercase;
            letter-spacing: 4px;
            margin-bottom: 20px;
        }

        .btn {
            background: transparent;
            border: 1px solid var(--white);
            color: var(--white);
            padding: 15px 40px;
            font-size: 1.1rem;
            cursor: pointer;
            margin: 15px;
            transition: 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px; 
            font-weight: bold;
        }
        .btn:hover {
            background: var(--white);
            color: black; 
            box-shadow: 0 0 40px var(--white); 
            transform: translateY(-3px); 
        }

        #hud {
            position: absolute; 
            top: 0; left: 0; width: 100%; padding: 30px;
            box-sizing: border-box;
            pointer-events: none;
            z-index: 10;
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start;
        }

        .stat-block {
            border-left: 4px solid var(--white); 
            padding-left: 15px; 
            background: rgba(0,0,0,0.4); 
            padding: 10px 20px; 
        }
        .label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px; 
        }
        .value {
            font-size: 2rem;
            font-weight: 900;
        }

        .hp-container { 
            width: 200px; 
            height: 12px; 
            background: rgba(255,0,0,0.1);
            border: 1px solid rgba(255,0,0,0.3); 
            margin-top: 5px; 
            overflow: hidden; 
        }
        #hp-fill { 
            height: 100%; width: 100%; 
            background: var(--red); 
            box-shadow: 0 0 10px var(--red); 
            transition: 0.3s; 
        }
        
        #shield-ui {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        .shield-node {
            width: 20px;
            height: 8px;
            background: #111111;
            border: 1px solid var(--white); 
        }
        .shield-node.active { 
            background: var(--white); 
            box-shadow: 0 0 10px var(--white); 
        }

        #boss-ui {
            position: absolute;
            top: 100px; 
            left: 50%; 
            transform: translateX(-50%);
            width: 50%; 
            display: none; 
            text-align: center; 
            z-index: 5;
        }
        .boss-hp-bg {
            width: 100%;
            height: 8px;
            background: #200; 
            border: 1px solid var(--red); 
            margin-top: 5px; 
        }
        #boss-hp-fill { 
            width: 100%; height: 100%; 
            background: var(--red); 
            box-shadow: 0 0 15px var(--red); 
        }

        .xp-rail { 
            position: absolute; 
            bottom: 0; left: 0; width: 100%; height: 5px; 
            background: #111; 
            z-index: 20; 
        }
        #xp-bar { 
            width: 0%; height: 100%; 
            background: var(--green); 
            box-shadow: 0 0 20px var(--green); 
            transition: 0.3s cubic-bezier(0.22, 1, 0.36, 1); 
        }

        #upgrade-container { 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            gap: 20px; 
            margin-top: 30px; 
            width: 100%; 
        }
        .upgrade-card {
            background: #050510; 
            border: 1px solid #222; 
            padding: 25px;
            cursor: pointer; 
            transition: 0.3s; 
            text-align: left; 
            position: relative; 
            overflow: hidden;
        }
        .upgrade-card:hover {
            border-color: var(--white); 
            background: #0a0a25; 
            transform: scale(1.05); 
        }
        .upgrade-card.rare { 
            border-color: var(--yellow); 
        }
        .u-name {
            color: var(--white); 
            font-weight: bold; 
            font-size: 1.2rem; 
            margin-bottom: 8px; 
        }
        .u-desc { 
            color: #aaa; 
            font-size: 0.85rem; 
            line-height: 1.4; 
        }

        #notif-feed {
            position: absolute; 
            right: 20px; 
            top: 150px;
            display: flex; 
            flex-direction: column; 
            gap: 10px; pointer-events: none;
        }
        .notif-msg {
            background: rgba(0,0,0,0.8); 
            border-right: 4px solid var(--yellow);
            padding: 10px 20px; 
            animation: slideIn 0.4s ease-out forwards;
        }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; } 
            to { transform: translateX(0); opacity: 1; } 
        }

    </style>
</head>
<body onload="Game.loadData()">

    <div id="crt-layer"></div>
    <div id="notif-feed"></div>

    <div id="screen-main" class="overlay">
        <div class="menu-card">
            <h1>Shooting Game</h1>
            <p style="color: #666; letter-spacing: 4px; margin-bottom: 40px;">by Hoang :)</p>
            <div id="high-score-display" style="color: var(--yellow); margin-bottom: 40px; font-size: 1.1rem; border: 1px solid #222; padding: 20px;">
                RECORDS // LOADING...
            </div>
            <button class="btn" onclick="Game.init()">Start</button>
        </div>
    </div>

    <div id="screen-upgrade" class="overlay hidden">
        <div class="menu-card" style="max-width: 900px; width: 95%;">
            <h2>Level Up!</h2>
            <div id="upgrade-container"></div>
        </div>
    </div>

    <div id="screen-death" class="overlay hidden">
        <div class="menu-card">
            <h1 style="color: var(--red);">You died</h1>
            <div id="death-stats" style="margin: 30px 0; font-family: monospace; color: #888; border: 1px solid #300; padding: 20px;"></div>
            <button class="btn" onclick="location.reload()">Re-Initialize</button>
        </div>
    </div>

    <div id="hud">
        <div class="stat-block">
            <div class="label">Health</div>
            <div class="hp-container"><div id="hp-fill"></div></div>
            <div id="shield-ui"></div>
            <div class="label" style="font-size: 0.5rem; margin-top: 5px;">Space to Active Shield</div>
        </div>
        <div style="text-align: center;">
            <div class="label">Level</div>
            <div class="value" id="lvl-val" style="color: var(--green);">1</div>
        </div>
        <div class="stat-block" style="text-align: right; border-left: none; border-right: 4px solid var(--white);">
            <div class="label">Best: <span id="hud-hi-score">0</span></div>
            <div class="value" id="score-val" style="color: var(--yellow);">0</div>
        </div>
    </div>

    

    <div id="boss-ui">
        <div class="label" id="boss-name">BOSS</div>
        <div class="boss-hp-bg"><div id="boss-hp-fill"></div></div>
    </div>

    <div class="xp-rail"><div id="xp-bar"></div></div>

    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const CONFIG = {
    BULLET_SPEED: 18,
    BASE_DMG: 15,
    START_HP: 100,
    XP_BASE: 150,
    XP_GROWTH: 1.5,
    SHIELD_DURATION: 180,
    COLORS: { blue: '#1E90FF', yellow: '#FFE5B4', purple: '#9b42f5', gold: '#ffcc00', enemy: '#ff3333' }
};

class Vec {
    constructor(x, y) { this.x = x; this.y = y; }
    static dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
    static angle(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }
}

class Starfield {
    constructor() {
        this.stars = [];
        for(let i=0; i<200; i++) {
            this.stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, z: Math.random() * 2 + 0.5, o: Math.random() });
        }
    }
    draw(playerPos) {
        ctx.fillStyle = "white";
        this.stars.forEach(s => {
            let sx = (s.x - playerPos.x * (s.z * 0.05)) % canvas.width;
            let sy = (s.y - playerPos.y * (s.z * 0.05)) % canvas.height;
            if(sx < 0) sx += canvas.width; if(sy < 0) sy += canvas.height;
            ctx.globalAlpha = s.o;
            ctx.beginPath(); ctx.arc(sx, sy, s.z, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;
    }
}

class Particle {
    constructor(x, y, color, size=2, speed=1) {
        this.pos = new Vec(x, y);
        let a = Math.random() * Math.PI * 2;
        let s = Math.random() * 5 * speed;
        this.vel = new Vec(Math.cos(a)*s, Math.sin(a)*s);
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.01;
        this.color = color;
        this.size = size;
    }
    update() { this.pos.x += this.vel.x; this.pos.y += this.vel.y; this.life -= this.decay; }
    draw() { ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.fillRect(this.pos.x, this.pos.y, this.size, this.size); }
}

class Projectile {
    constructor(x, y, angle, stats, isEnemy = false) {
        this.pos = new Vec(x, y);
        this.vel = new Vec(Math.cos(angle) * CONFIG.BULLET_SPEED, Math.sin(angle) * CONFIG.BULLET_SPEED);
        this.dmg = stats.dmg;
        this.pierce = stats.pierce;
        this.isEnemy = isEnemy;
        this.radius = isEnemy ? 6 : 4;
        this.dead = false;
        this.hitTargets = new Set();
        this.color = isEnemy ? CONFIG.COLORS.yellow : "white";
    }
    update() {
        this.pos.x += this.vel.x; this.pos.y += this.vel.y;
        if(this.pos.x < -50 || this.pos.x > canvas.width + 50 || this.pos.y < -50 || this.pos.y > canvas.height + 50) this.dead = true;
    }
    draw() {
        ctx.shadowBlur = this.isEnemy ? 15 : 10; ctx.shadowColor = this.color; ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
    }
}

class Enemy {
    constructor(x, y, type = 'drone') {
        this.pos = new Vec(x, y); this.type = type; this.dead = false; this.angle = 0; this.frame = 0;
        this.setup();
    }
    setup() {
        const lv = Game.level;
        switch(this.type) {
            case 'stalker': this.hp = 25 + (lv * 8); this.speed = 3.5; this.r = 16; this.color = CONFIG.COLORS.gold; break;
            case 'sniper': this.hp = 20 + (lv * 5); this.speed = 1.5; this.r = 18; this.color = CONFIG.COLORS.blue; this.fireRate = 120; break;
            case 'heavy': this.hp = 120 + (lv * 30); this.speed = 1.0; this.r = 35; this.color = CONFIG.COLORS.enemy; break;
            case 'boss': this.hp = 1000 + (lv * 200); this.maxHp = this.hp; this.speed = 0.8; this.r = 80; this.color = CONFIG.COLORS.yellow; break;
            default: this.hp = 35 + (lv * 5); this.speed = 2.2; this.r = 22; this.color = CONFIG.COLORS.yellow;
        }
        this.maxHp = this.hp;
    }
    update(pPos) {
        this.frame++; this.angle = Vec.angle(this.pos, pPos);
        if (this.type === 'sniper') {
            const d = Vec.dist(this.pos, pPos);
            if(d < 400) { this.pos.x -= Math.cos(this.angle) * this.speed; this.pos.y -= Math.sin(this.angle) * this.speed; }
            else if(d > 450) { this.pos.x += Math.cos(this.angle) * this.speed; this.pos.y += Math.sin(this.angle) * this.speed; }
            if(this.frame % this.fireRate === 0) this.shoot();
        } else if (this.type === 'boss') {
            this.pos.x += Math.cos(this.angle) * this.speed; this.pos.y += Math.sin(this.angle) * this.speed;
            if(this.frame % 60 === 0) this.bossPatterns();
        } else {
            this.pos.x += Math.cos(this.angle) * this.speed; this.pos.y += Math.sin(this.angle) * this.speed;
        }
    }
    shoot() { Game.enemyProjectiles.push(new Projectile(this.pos.x, this.pos.y, this.angle, {dmg: 10}, true)); }
    bossPatterns() {
        for(let i=0; i<12; i++) {
            const a = (Math.PI*2 / 12) * i + (this.frame * 0.01);
            Game.enemyProjectiles.push(new Projectile(this.pos.x, this.pos.y, a, {dmg: 15}, true));
        }
    }
    draw() {
        ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.strokeStyle = this.color; ctx.lineWidth = 3;
        ctx.beginPath();
        if(this.type === 'heavy') ctx.rect(this.pos.x - this.r, this.pos.y - this.r, this.r*2, this.r*2);
        else if(this.type === 'stalker') { ctx.moveTo(this.pos.x, this.pos.y - this.r); ctx.lineTo(this.pos.x + this.r, this.pos.y + this.r); ctx.lineTo(this.pos.x - this.r, this.pos.y + this.r); ctx.closePath(); }
        else if(this.type === 'boss') { ctx.arc(this.pos.x, this.pos.y, this.r, 0, Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.r - 20, 0, Math.PI*2); }
        else ctx.arc(this.pos.x, this.pos.y, this.r, 0, Math.PI*2);
        ctx.stroke(); ctx.shadowBlur = 0;
        if(this.hp < this.maxHp) {
            ctx.fillStyle = '#222'; ctx.fillRect(this.pos.x - this.r, this.pos.y - this.r - 15, this.r*2, 6);
            ctx.fillStyle = this.color; ctx.fillRect(this.pos.x - this.r, this.pos.y - this.r - 15, (this.r*2) * (this.hp/this.maxHp), 6);
        }
    }
}

const Game = {
    running: false, paused: false,
    score: 0, level: 1, xp: 0, nextXp: CONFIG.XP_BASE,
    hp: CONFIG.START_HP, frame: 0, shake: 0,
    player: {
        pos: new Vec(0, 0), r: 18, fireDelay: 0, activeShield: 0, shields: 1,
        stats: { speed: 5, dmg: CONFIG.BASE_DMG, fireRate: 250, multi: 1, pierce: false, crit: 0.1 }
    },
    stars: null, bullets: [], enemies: [], particles: [], enemyProjectiles: [],
    keys: {}, mouse: { x:0, y:0, down: false }, bossActive: false,

    init() {
        this.loadData();
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        this.stars = new Starfield();
        this.player.pos = new Vec(canvas.width/2, canvas.height/2);
        
        window.addEventListener('keydown', e => {
            this.keys[e.key.toLowerCase()] = true;
            if(e.code === 'Space') this.triggerShield();
            if(e.key === 'p' || e.key === 'Escape') this.togglePause();
        });
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => this.mouse.down = true);
        window.addEventListener('mouseup', () => this.mouse.down = false);
        
        document.getElementById('screen-main').classList.add('hidden');
        this.running = true;
        this.updateHUD();
        this.loop();
    },

    triggerShield() {
        if(this.player.shields > 0 && this.player.activeShield <= 0) {
            this.player.shields--;
            this.player.activeShield = CONFIG.SHIELD_DURATION;
            this.notify("TACTICAL PULSE ACTIVE");
            this.updateHUD();
        }
    },

    togglePause() { if(!this.running) return; this.paused = !this.paused; },

    spawnHandler() {
        if(this.bossActive) return;
        if(this.level % 5 === 0 && this.enemies.length === 0) { this.spawnBoss(); return; }
        if(this.frame % Math.max(15, 70 - this.level * 3) === 0) {
            let x, y;
            if(Math.random() < 0.5) { x = Math.random() < 0.5 ? -100 : canvas.width + 100; y = Math.random() * canvas.height; }
            else { x = Math.random() * canvas.width; y = Math.random() < 0.5 ? -100 : canvas.height + 100; }
            let type = 'drone'; let r = Math.random();
            if(this.level > 2 && r < 0.15) type = 'stalker';
            if(this.level > 4 && r < 0.3) type = 'sniper';
            if(this.level > 7 && r < 0.45) type = 'heavy';
            this.enemies.push(new Enemy(x, y, type));
        }
    },

    spawnBoss() {
        this.bossActive = true; const b = new Enemy(canvas.width/2, -200, 'boss'); this.enemies.push(b);
        document.getElementById('boss-ui').style.display = 'block'; this.notify("BOSS ENCOUNTER INITIATED");
    },

    update() {
        if(!this.running || this.paused) return;
        this.frame++;

        let mvX = 0, mvY = 0;
        if(this.keys['w']) mvY -= 1; if(this.keys['s']) mvY += 1; if(this.keys['a']) mvX -= 1; if(this.keys['d']) mvX += 1;
        if(mvX !== 0 || mvY !== 0) {
            let m = Math.hypot(mvX, mvY);
            this.player.pos.x += (mvX/m) * this.player.stats.speed;
            this.player.pos.y += (mvY/m) * this.player.stats.speed;
        }

        this.player.pos.x = Math.max(20, Math.min(canvas.width - 20, this.player.pos.x));
        this.player.pos.y = Math.max(20, Math.min(canvas.height - 20, this.player.pos.y));

        if(this.player.activeShield > 0) this.player.activeShield--;

        if(this.mouse.down && this.player.fireDelay <= 0) {
            const angle = Vec.angle(this.player.pos, this.mouse);
            for(let i=0; i<this.player.stats.multi; i++) {
                const spread = (i - (this.player.stats.multi - 1) / 2) * 0.15;
                this.bullets.push(new Projectile(this.player.pos.x, this.player.pos.y, angle + spread, this.player.stats));
            }
            this.player.fireDelay = this.player.stats.fireRate; this.shake = 4;
        }
        if(this.player.fireDelay > 0) this.player.fireDelay -= 16.6;

        this.bullets.forEach((b, i) => {
            b.update(); if(b.dead) this.bullets.splice(i, 1);
            this.enemies.forEach(e => {
                if(b.hitTargets.has(e)) return;
                if(Vec.dist(b.pos, e.pos) < e.r + b.radius) {
                    let d = b.dmg; if(Math.random() < this.player.stats.crit) d *= 2;
                    e.hp -= d; if(!this.player.stats.pierce) b.dead = true; else b.hitTargets.add(e);
                    if(e.type === 'boss') document.getElementById('boss-hp-fill').style.width = (e.hp/e.maxHp*100) + '%';
                    if(e.hp <= 0 && !e.dead) { e.dead = true; this.killEnemy(e); }
                }
            });
        });

        this.enemies.forEach((e, i) => {
            e.update(this.player.pos);
            if(Vec.dist(this.player.pos, e.pos) < e.r + this.player.r) {
                if(this.player.activeShield > 0) { e.dead = true; this.killEnemy(e); }
                else { this.takeDamage(0.5); this.shake = 10; }
            }
            if(e.dead) this.enemies.splice(i, 1);
        });

        this.enemyProjectiles.forEach((ep, i) => {
            ep.update();
            if(Vec.dist(ep.pos, this.player.pos) < ep.radius + this.player.r) {
                if(this.player.activeShield > 0) { ep.dead = true; }
                else { this.takeDamage(10); ep.dead = true; this.shake = 15; }
            }
            if(ep.dead) this.enemyProjectiles.splice(i, 1);
        });

        this.particles.forEach((p, i) => { p.update(); if(p.life <= 0) this.particles.splice(i, 1); });
        if(this.shake > 0) this.shake *= 0.85;
        this.spawnHandler();
    },

    killEnemy(e) {
        this.score += e.type === 'boss' ? 5000 : e.type === 'heavy' ? 400 : 100; this.xp += 30;
        if(e.type === 'boss') { this.bossActive = false; document.getElementById('boss-ui').style.display = 'none'; this.notify("GATEKEEPER TERMINATED"); }
        this.updateHUD();
        if(this.xp >= this.nextXp) this.levelUp();
    },

    takeDamage(v) { this.hp -= v; this.updateHUD(); if(this.hp <= 0) this.gameOver(); },

    levelUp() {
        this.level++; this.xp = 0; this.nextXp *= CONFIG.XP_GROWTH; this.paused = true;
        this.showUpgradeMenu(); this.notify("LEVEL UP!");
    },

    showUpgradeMenu() {
        const container = document.getElementById('upgrade-container'); container.innerHTML = '';
        document.getElementById('screen-upgrade').classList.remove('hidden');
        const pool = [
            { n: 'Recovery', d: '+60% Health', run: () => this.hp = Math.min(100, this.hp + 100) },
            { n: 'Shield', d: '+2 Pulse Charge', run: () => this.player.shields += 2 },
            { n: 'Speed', d: '30% SPD', run: () => this.player.stats.speed *= 1.30 },
            { n: 'Damage', d: '+30% DMG', run: () => this.player.stats.dmg *= 130 },
            { n: 'Split Shot', d: '+1 Projectile', run: () => this.player.stats.multi += 1 },
            { n: 'Fire Time', d: '-75ms FireTime', run: () => Math.min(50, this.fireRate -= 75)}
        ];
        pool.sort(() => 0.5 - Math.random()).slice(0, 3).forEach(u => {
            const div = document.createElement('div'); div.className = 'upgrade-card';
            div.innerHTML = `<div class="u-name">${u.n}</div><div class="u-desc">${u.d}</div>`;
            div.onclick = () => { u.run(); this.paused = false; document.getElementById('screen-upgrade').classList.add('hidden'); this.updateHUD(); };
            container.appendChild(div);
        });
    },

    updateHUD() {
        document.getElementById('hp-fill').style.width = Math.max(0, this.hp) + '%';
        document.getElementById('score-val').innerText = Math.floor(this.score);
        document.getElementById('lvl-val').innerText = this.level;
        document.getElementById('xp-bar').style.width = (this.xp / this.nextXp * 100) + '%';
        
        const sUI = document.getElementById('shield-ui'); sUI.innerHTML = '';
        for(let i=0; i<this.player.shields; i++) {
            const n = document.createElement('div'); n.className = 'shield-node active'; sUI.appendChild(n);
        }
    },

    notify(m) {
        const feed = document.getElementById('notif-feed'); const d = document.createElement('div');
        d.className = 'notif-msg'; d.innerText = m; feed.appendChild(d); setTimeout(() => d.remove(), 3000);
    },

    draw() {
        ctx.fillStyle = 'rgba(2, 2, 5, 0.25)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.save(); if(this.shake > 0.5) ctx.translate(Math.random() * this.shake, Math.random() * this.shake);
        this.stars.draw(this.player.pos);

        if(this.player.activeShield > 0) {
            ctx.strokeStyle = CONFIG.COLORS.blue; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(this.player.pos.x, this.player.pos.y, this.player.r + 20, 0, Math.PI*2); ctx.stroke();
            ctx.globalAlpha = 0.2; ctx.fillStyle = CONFIG.COLORS.blue; ctx.fill(); ctx.globalAlpha = 1;
        }

        ctx.strokeStyle = CONFIG.COLORS.blue; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.arc(this.player.pos.x, this.player.pos.y, this.player.r, 0, Math.PI*2); ctx.stroke();
        this.bullets.forEach(b => b.draw()); this.enemyProjectiles.forEach(ep => ep.draw());
        this.enemies.forEach(e => e.draw()); this.particles.forEach(p => p.draw());
        ctx.restore();
    },

    saveData() {
        const bestS = localStorage.getItem('cyberS') || 0;
        const bestL = localStorage.getItem('cyberL') || 1;
        if(this.score > bestS) localStorage.setItem('cyberS', Math.floor(this.score));
        if(this.level > bestL) localStorage.setItem('cyberL', this.level);
    },

    loadData() {
        const s = localStorage.getItem('cyberS') || 0;
        const l = localStorage.getItem('cyberL') || 1;
        document.getElementById('high-score-display').innerText = `RECORDS: SCORE: ${s} | LEVEL: ${l}`;
        document.getElementById('hud-hi-score').innerText = s;
    },

    gameOver() {
        this.running = false; this.saveData();
        document.getElementById('screen-death').classList.remove('hidden');
        document.getElementById('death-stats').innerHTML = `
            FINAL SCORE: ${Math.floor(this.score)}<br>
            LEVEL REACHED: ${this.level}<br>
            MAX RECORD: ${localStorage.getItem('cyberS')}
        `;
    },

    loop() { this.update(); this.draw(); if(this.running) requestAnimationFrame(() => this.loop()); }
};

window.onresize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
</script>
</body>
</html>
